module core;

abstract type Function0[+R] {
  R get();
}

abstract type Function1[-T1, +R] {
  R get(T1 v1);
}

abstract type Function2[-T1, -T2, +R] {
  R get(T1 v1, T2 v2);
}

abstract type Predicate0 extends Function0[Bool] {
  Predicate0 &(Predicate0 that) {
    return new Conjunction0(this, that);
  }

  Predicate0 |(Predicate0 that) {
    return new Disjunction0(this, that);
  }

  Predicate0 ^(Predicate0 that) {
    return new ExclusiveDisjunction0(this, that);
  }
}

abstract type Predicate1[-T1] extends Function1[T1, Bool] {
  Predicate1[T1] &(Predicate1[T1] that) {
    return new Conjunction1(this, that);
  }

  Predicate1[T1] |(Predicate1[T1] that) {
    return new Disjunction1(this, that);
  }

  Predicate1[T1] ^(Predicate1[T1] that) {
    return new ExclusiveDisjunction1(this, that);
  }
}

abstract type Predicate2[-T1, -T2] extends Function2[T1, T2, Bool] {
  Predicate2[T1, T2] &(Predicate2[T1, T2] that) {
    return new Conjunction2(this, that);
  }

  Predicate2[T1, T2] |(Predicate2[T1, T2] that) {
    return new Disjunction2(this, that);
  }

  Predicate2[T1, T2] ^(Predicate2[T1, T2] that) {
    return new ExclusiveDisjunction2(this, that);
  }
}

type Conjunction0 extends Predicate0 {
  Predicate0 p, q;

  Void init(Predicate0 p, Predicate0 q) {
    this.p = p;
    this.p = p;
  }

  Bool get() {
    return this.p() & this.q();
  }
}

type Conjunction1[-T1] extends Predicate1[T1] {
  Predicate1 p, q;

  Void init(Predicate1 p, Predicate1 q) {
    this.p = p;
    this.q = q;
  }

  Bool get(T1 v1) {
    return this.p(v1) & this.q(v1);
  }
}

type Conjunction2[-T1, -T2] extends Predicate2[T1, T2] {
  Predicate1 p, q;

  Void init(Predicate1 p, Predicate1 q) {
    this.p = p;
    this.q = q;
  }

  Bool get(T1 v1, T2 v2) {
    return this.p(v1, v2) & this.q(v1, v2);
  }
}

type Disjunction0 extends Predicate0 {
  Predicate0 p, q;

  Void init(Predicate0 p, Predicate0 q) {
    this.p = p;
    this.p = p;
  }

  Bool get() {
    return this.p() | this.q();
  }
}

type Disjunction1[-T1] extends Predicate1[T1] {
  Predicate1 p, q;

  Void init(Predicate1 p, Predicate1 q) {
    this.p = p;
    this.q = q;
  }

  Bool get(T1 v1) {
    return this.p(v1) | this.q(v1);
  }
}

type Disjunction2[-T1, -T2] extends Predicate2[T1, T2] {
  Predicate1 p, q;

  Void init(Predicate1 p, Predicate1 q) {
    this.p = p;
    this.q = q;
  }

  Bool get(T1 v1, T2 v2) {
    return this.p(v1, v2) | this.q(v1, v2);
  }
}

type ExclusiveDisjunction0 extends Predicate0 {
  Predicate0 p, q;

  Void init(Predicate0 p, Predicate0 q) {
    this.p = p;
    this.p = p;
  }

  Bool get() {
    return this.p() ^ this.q();
  }
}

type ExclusiveDisjunction1[-T1] extends Predicate1[T1] {
  Predicate1 p, q;

  Void init(Predicate1 p, Predicate1 q) {
    this.p = p;
    this.q = q;
  }

  Bool get(T1 v1) {
    return this.p(v1) ^ this.q(v1);
  }
}

type ExclusiveDisjunction2[-T1, -T2] extends Predicate2[T1, T2] {
  Predicate1 p, q;

  Void init(Predicate1 p, Predicate1 q) {
    this.p = p;
    this.q = q;
  }

  Bool get(T1 v1, T2 v2) {
    return this.p(v1, v2) ^ this.q(v1, v2);
  }
}

type ConstantFunction0[+R] extends Function0[R] {
  R value;

  Void init(R value) {
    this.value = value;
  }

  R get() {
    return this.value;
  }
}

type ConstantFunction1[-T1, +R] extends Function1[T1, R] {
  R value;

  Void init(R value) {
    this.value = value;
  }

  R get(T1 v1) {
    return this.value;
  }
}

type ConstantFunction2[-T1, -T2, +R] extends Function2[T1, T2, R] {
  R value;

  Void init(R value) {
    this.value = value;
  }

  R get(T1 v1, T2 v2) {
    return this.value;
  }
}

type IdentityFunction[T] extends Function1[T, T] {
  Void init() {}

  T get(T v) {
    return v;
  }
}
