module core;

abstract type Sequence[+T] extends Collection[T] {
  T get(Int idx) {
    # TODO bounds check
    Iterator[T] iter = this.iterator();
    while (idx > 0) {
      iter.next();
      idx = idx - 1;
    }
    return iter.next().get();
  }

  T first() {
    return this(0);
  }

  Maybe[T] last() {
    if (this.isEmpty())
      return new None[T]();
    else
      return Some[T](this(this.size() - 1));
  }

  Sequence[T] first(Int n) {
    List[T] result = new EmptyList[T]();
    Iterator[T] iter = this.iterator();
    Maybe[T] current = iter.next();
    while (current.isSomething() & result.size() < n) {
      result = new NonEmptyList[T](current.get(), result);
      current = iter.next();
    }
    return result.reverse();
  }

  Sequence[T] last(Int n) {
    return this.reverse().first(n).reverse();
  }

  Maybe[Int] firstIndexOf(T elem) {
    Iterator[T] iter = this.iterator();
    Int i = 0;
    Maybe[T] current = iter.next();
    while (current.isSomething()) {
      if (current.get() == elem)
        return Some[Int](i);
      i = i + 1;
      current = iter.next();
    }
    return new None[Int]();
  }

  Maybe[Int] lastIndexOf(T elem) {
    Maybe[Int] i = this.reverse().firstIndexOf(elem);
    if (i.isNothing())
      return i;
    return Some[Int](this.size() - 1 - i.get());
  }

  Sequence[T] reverse() {
    List[T] result = new EmptyList[T]();
    for (T elem : this)
      result = new NonEmptyList[T](elem, result);
    return result;
  }

  Sequence[T] +(Sequence[T] that) {
    List[T] result = new EmptyList[T]();
    for (T elem : this)
      result = new NonEmptyList[T](elem, result);
    for (T elem : that)
      result = new NonEmptyList[T](elem, result);
    return result.reverse();
  }

  Sequence[T] *(Int n) {
    List[T] result = new EmptyList[T]();
    for (Int i = 0; i < n; i = i + 1)
      for (T elem : this)
        result = new NonEmptyList[T](elem, result);
    return result.reverse();
  }
}
