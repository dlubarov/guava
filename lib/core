module core;

type Object {
  Bool ==(Object that) {}

  Bool !=(Object that) {
    return !(this == that);
  }

  Int hashCode() {}

  String toString() {}
}

type Int {
  Int +() {}
  Int -() {}
  Int ~() {}

  Int +(Int that) {}
  Int -(Int that) {}
  Int *(Int that) {}
  Int /(Int that) {}
  Int %(Int that) {}
  Int &(Int that) {}
  Int |(Int that) {}
  Int ^(Int that) {}
  Int <<(Int that) {}
  Int >>(Int that) {}

  Bool <(Int that) {}
  Bool >(Int that) {}
  Bool <=(Int that) {}
  Bool >=(Int that) {}

  Bool ==(Object that) {}
  Int hashCode() {}
  String toString() {}
}

type Bool {
  Bool !() {}

  Bool &(Bool that) {}
  Bool |(Bool that) {}
  Bool ^(Bool that) {}

  Bool ==(Object that) {}
  Int hashCode() {}
  String toString() {}
}

type Char {
  Bool ==(Object that) {}
  Int hashCode() {}
  String toString() {}
}

type String extends Sequence[Char] {
}

type Maybe[+T] extends Iterable[T] {
  Bool isSomething();
}

type Some[+T] extends Maybe[T] {
  T value;

  Bool isSomething() {
    return true;
  }

  Iterator[T] iterator() {
    return new SingletonIterator[T](this.value);
  }
}

type None[+T] extends Maybe[T] {
  Bool isSomething() {
    return false;
  }

  Iterator[T] iterator() {
    return new EmptyIterator[T]();
  }
}

type Iterator[+T] {
  Maybe[T] next();

  Bool hasNext() {
    return this.next().isSomething();
  }
}

type EmptyIterator[+T] extends Iterator[T] {
  Maybe[T] next() {
    return new None[T]();
  }
}

type SingletonIterator[+T] extends Iterator[T] {
  T value;
  Bool used;

  Maybe[T] next() {
    if (this.used)
      new None[T]();
    else {
      this.used = true;
      return new Some[T](this.value);
    }
  }
}

type Iterable[+T] {
  Iterator[T] iterator();
}

type Collection[+T] extends Iterable[T] {
}

type Sequence[+T] extends Collection[T] {
}
