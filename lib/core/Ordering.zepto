module core;

# Used to enforce trichotomy.
public type Relation {
  public static readonly Relation LT, GT, EQ;

  private static Unit init() {
    Relation.LT = new Relation();
    Relation.GT = new Relation();
    Relation.EQ = new Relation();
  }

  private Unit init() {}

  public Relation flip() {
    if (this == Relation.LT)
      return Relation.GT;
    if (this == Relation.GT)
      return Relation.LT;
    return Relation.EQ;
  }
}

public abstract type PartialOrdering[-T] {
  public Maybe[Relation] compare(T a, T b);
}

public abstract type Ordering[-T] extends PartialOrdering[T] {
  public Some[Relation] compare(T a, T b);
}

public abstract type NaturallyOrdered[-T] {
  public Ordering[T] naturalOrdering();

  public Relation compareTo(T that) {
    return this.naturalOrdering().compare(this, that).get();
  }

  public Bool <(T that) {
    return this.compareTo(that) == Relation.LT;
  }

  public Bool >(T that) {
    return this.compareTo(that) == Relation.GT;
  }

  public Bool ==(T that) {
    return this.compareTo(that) == Relation.EQ;
  }

  public Bool <=(T that) {
    return this < that | this == that;
  }

  public Bool >=(T that) {
    return this > that | this == that;
  }
}

public type ReverseOrdering[-T] extends Ordering[T] {
  private readonly Ordering[T] original;

  public Unit init(Ordering[T] original) {
    this.original = original;
  }

  public Relation compareTo(T that) {
    return original.compareTo(that).flip();
  }
}

public type LexicographicOrdering[-T] extends Ordering[Sequence[T]] {
  public Some[Relation] compare(Sequence[T] a, Sequence[T] b) {
    Source[T] enumA = a.enumerator(), enumB = b.enumerator();
  }
}
